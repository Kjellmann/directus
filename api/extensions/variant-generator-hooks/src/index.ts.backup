import type { HookConfig } from '@directus/extensions';
import { VariantGeneratorService } from './variant-generator-service';

const registerHook: HookConfig = ({ action, filter }, { services, getSchema, database, logger }) => {
	// Helper function to get variant generator service
	const getVariantService = async (accountability: Record<string, any> | null) => {
		const schema = await getSchema({ database });
		return new VariantGeneratorService({
			knex: database,
			accountability: accountability as any,
			schema,
			services,
			logger,
		});
	};

	// Hook: Generate variants when family variant axes are created/updated
	action('family_variant_axes.items.create', async ({ key, accountability }) => {
		try {
			logger.info('Family variant axis created, generating variants...');
			const variantService = await getVariantService(accountability);
			
			// Get the family variant ID from the created axis
			const axis = await database('family_variant_axes')
				.where('id', key)
				.first();
			
			if (axis) {
				await variantService.generateVariantsForFamilyVariant(axis.family_variants_id);
			}
		} catch (error) {
			logger.error('Error in family_variant_axes.create hook:', error);
		}
	});

	action('family_variant_axes.items.update', async ({ keys, accountability }) => {
		try {
			logger.info('Family variant axis updated, regenerating variants...');
			const variantService = await getVariantService(accountability);
			
			// Get unique family variant IDs from updated axes
			const axes = await database('family_variant_axes')
				.whereIn('id', keys)
				.select('family_variants_id');
			
			const uniqueFamilyVariantIds = [...new Set(axes.map(a => a.family_variants_id))];
			
			// Regenerate variants for each affected family variant
			for (const familyVariantId of uniqueFamilyVariantIds) {
				await variantService.generateVariantsForFamilyVariant(familyVariantId);
			}
		} catch (error) {
			logger.error('Error in family_variant_axes.update hook:', error);
		}
	});

	action('family_variant_axes.items.delete', async ({ keys, accountability }) => {
		try {
			logger.info('Family variant axis deleted, regenerating variants...');
			const variantService = await getVariantService(accountability);
			
			// Get family variant IDs before deletion (we need to store them first)
			const axes = await database('family_variant_axes')
				.whereIn('id', keys)
				.select('family_variants_id');
			
			const uniqueFamilyVariantIds = [...new Set(axes.map(a => a.family_variants_id))];
			
			// After deletion, regenerate variants
			setTimeout(async () => {
				for (const familyVariantId of uniqueFamilyVariantIds) {
					await variantService.generateVariantsForFamilyVariant(familyVariantId);
				}
			}, 100);
		} catch (error) {
			logger.error('Error in family_variant_axes.delete hook:', error);
		}
	});

	// Hook: Generate variants when a model product is created with a family variant
	action('products.items.create', async ({ payload, key, accountability }) => {
		try {
			// Check if this is a product_model with a family variant
			if (payload.product_type === 'product_model' && payload.family_variant) {
				logger.info(`Product model ${key} created with family variant ${payload.family_variant}, generating variants...`);
				const variantService = await getVariantService(accountability);
				await variantService.generateVariantsForProduct(key);
			}
		} catch (error) {
			logger.error('Error in products.create hook:', error);
		}
	});

	// Hook: Handle updates to model products
	action('products.items.update', async ({ payload, keys, accountability }) => {
		try {
			const variantService = await getVariantService(accountability);
			
			// Check each updated product
			for (const productId of keys) {
				const product = await database('products')
					.where('id', productId)
					.first();
				
				if (product && product.product_type === 'product_model') {
					// Check if family_variant was changed
					if (payload.family_variant !== undefined) {
						logger.info(`Product model ${productId} family variant changed, regenerating variants...`);
						
						// Delete old variants if family variant was removed
						if (!payload.family_variant && product.family_variant) {
							const oldVariants = await database('products')
								.where('parent_product_id', productId)
								.where('product_type', 'simple')
								.select('id');
							
							if (oldVariants.length > 0) {
								const { ItemsService } = services;
								const productsService = new ItemsService('products', { 
									accountability,
									schema: await getSchema({ database })
								});
								await productsService.deleteMany(oldVariants.map(v => v.id));
							}
						}
						
						// Generate new variants if family variant is set
						if (payload.family_variant) {
							await variantService.generateVariantsForProduct(productId);
						}
					}
				}
			}
		} catch (error) {
			logger.error('Error in products.update hook:', error);
		}
	});

	// Hook: Clean up variants when model product is deleted
	filter('products.items.delete', async (keys) => {
		try {
			// Find and delete all child variants
			const variants = await database('products')
				.whereIn('parent_product_id', keys as number[])
				.where('product_type', 'simple')
				.select('id');
			
			if (variants.length > 0) {
				logger.info(`Deleting ${variants.length} variants for deleted product models`);
				(keys as number[]).push(...variants.map(v => v.id));
			}
		} catch (error) {
			logger.error('Error in products.delete filter:', error);
		}
		
		return keys as number[];
	});

	// Hook: Regenerate variants when attribute values are added to variant axes
	action('attribute_values.items.create', async ({ payload, accountability }) => {
		try {
			// Find family variants that use this attribute in their axes
			const affectedAxes = await database('family_variant_axes')
				.where('attributes_id', payload.attribute_id)
				.select('family_variants_id');
			
			if (affectedAxes.length > 0) {
				logger.info(`New attribute value created, checking variant regeneration for ${affectedAxes.length} family variants...`);
				const variantService = await getVariantService(accountability);
				
				const uniqueFamilyVariantIds = [...new Set(affectedAxes.map(a => a.family_variants_id))];
				
				for (const familyVariantId of uniqueFamilyVariantIds) {
					// Check if this family variant uses automatic value selection (no selected_value_ids)
					const axes = await database('family_variant_axes')
						.where('family_variants_id', familyVariantId)
						.where('attributes_id', payload.attribute_id)
						.first();
					
					if (axes && (!axes.selected_value_ids || axes.selected_value_ids.length === 0)) {
						// Only regenerate if using automatic selection
						await variantService.generateVariantsForFamilyVariant(familyVariantId);
					}
				}
			}
		} catch (error) {
			logger.error('Error in attribute_values.create hook:', error);
		}
	});

	// Hook: Handle attribute value updates
	action('attribute_values.items.update', async ({ keys, accountability }) => {
		try {
			// Get attribute IDs for updated values
			const values = await database('attribute_values')
				.whereIn('id', keys)
				.select('attribute_id');
			
			const uniqueAttributeIds = [...new Set(values.map(v => v.attribute_id))];
			
			// Find affected family variants
			const affectedAxes = await database('family_variant_axes')
				.whereIn('attributes_id', uniqueAttributeIds)
				.select('family_variants_id');
			
			if (affectedAxes.length > 0) {
				logger.info(`Attribute values updated, regenerating variants for affected family variants...`);
				const variantService = await getVariantService(accountability);
				
				const uniqueFamilyVariantIds = [...new Set(affectedAxes.map(a => a.family_variants_id))];
				
				for (const familyVariantId of uniqueFamilyVariantIds) {
					await variantService.generateVariantsForFamilyVariant(familyVariantId);
				}
			}
		} catch (error) {
			logger.error('Error in attribute_values.update hook:', error);
		}
	});

	// Hook: Handle attribute value deletion
	action('attribute_values.items.delete', async ({ keys, accountability }) => {
		try {
			// Note: We need to capture the attribute IDs before deletion
			const values = await database('attribute_values')
				.whereIn('id', keys)
				.select('attribute_id');
			
			const uniqueAttributeIds = [...new Set(values.map(v => v.attribute_id))];
			
			// Find affected family variants
			const affectedAxes = await database('family_variant_axes')
				.whereIn('attributes_id', uniqueAttributeIds)
				.select('family_variants_id');
			
			if (affectedAxes.length > 0) {
				logger.info(`Attribute values deleted, regenerating variants for affected family variants...`);
				
				// Delay regeneration to ensure deletion is complete
				setTimeout(async () => {
					const variantService = await getVariantService(accountability);
					const uniqueFamilyVariantIds = [...new Set(affectedAxes.map(a => a.family_variants_id))];
					
					for (const familyVariantId of uniqueFamilyVariantIds) {
						await variantService.generateVariantsForFamilyVariant(familyVariantId);
					}
				}, 100);
			}
		} catch (error) {
			logger.error('Error in attribute_values.delete hook:', error);
		}
	});
};

export default registerHook;