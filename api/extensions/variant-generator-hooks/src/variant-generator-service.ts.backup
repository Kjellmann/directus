import type { Knex } from 'knex';
import type { Accountability, SchemaOverview } from '@directus/types';
import { createHash } from 'crypto';

interface VariantAxis {
	id: number;
	attribute_id: number;
	attribute_code: string;
	selected_value_ids: number[];
	sort: number;
}

interface AttributeValue {
	id: number;
	value: any;
	label: string;
	attribute_id: number;
}

interface VariantCombination {
	[attributeCode: string]: {
		id: number;
		value: any;
		label: string;
		attribute_id: number;
	};
}

interface GenerationResult {
	created: number;
	updated: number;
	deleted: number;
	errors: string[];
}

export class VariantGeneratorService {
	knex: Knex;
	accountability: Accountability | null;
	schema: SchemaOverview;
	services: Record<string, any>;
	logger: Record<string, any>;

	constructor(options: {
		knex: Knex;
		accountability: Accountability | null;
		schema: SchemaOverview;
		services: Record<string, any>;
		logger: Record<string, any>;
	}) {
		this.knex = options.knex;
		this.accountability = options.accountability;
		this.schema = options.schema;
		this.services = options.services;
		this.logger = options.logger;
	}

	/**
	 * Generate variants for a specific family variant
	 */
	async generateVariantsForFamilyVariant(familyVariantId: number): Promise<GenerationResult> {
		const result: GenerationResult = {
			created: 0,
			updated: 0,
			deleted: 0,
			errors: [],
		};

		try {
			// Get all model products using this family variant
			const modelProducts = await this.knex('products')
				.where('family_variant', familyVariantId)
				.where('product_type', 'product_model')
				.select('id', 'family', 'family_variant');

			this.logger.info(
				`Generating variants for ${modelProducts.length} model products with family variant ${familyVariantId}`,
			);

			// Generate variants for each model product
			for (const modelProduct of modelProducts) {
				const productResult = await this.generateVariantsForProduct(modelProduct.id);
				result.created += productResult.created;
				result.updated += productResult.updated;
				result.deleted += productResult.deleted;
				result.errors.push(...productResult.errors);
			}

			// Log generation results
			await this.logGeneration(familyVariantId, null, 'generate', result);

			return result;
		} catch (error) {
			this.logger.error(`Error generating variants for family variant ${familyVariantId}:`, error);
			result.errors.push(error instanceof Error ? error.message : String(error));
			return result;
		}
	}

	/**
	 * Generate variants for a specific model product
	 */
	async generateVariantsForProduct(productId: number): Promise<GenerationResult> {
		const result: GenerationResult = {
			created: 0,
			updated: 0,
			deleted: 0,
			errors: [],
		};

		try {
			// Get the model product details
			const modelProduct = await this.knex('products').where('id', productId).first();

			if (!modelProduct) {
				throw new Error(`Product ${productId} not found`);
			}

			if (modelProduct.product_type !== 'product_model') {
				throw new Error(`Product ${productId} is not a product_model type`);
			}

			if (!modelProduct.family_variant) {
				this.logger.info(`Product ${productId} has no family variant, skipping variant generation`);
				return result;
			}

			// Get variant axes and their selected values
			const axes = await this.getVariantAxes(modelProduct.family_variant);

			if (axes.length === 0) {
				this.logger.info(`No variant axes configured for family variant ${modelProduct.family_variant}`);
				return result;
			}

			// Get selected attribute values for each axis
			// For product_model types, check product-level selections first
			const selectedValues =
				modelProduct.product_type === 'product_model'
					? await this.getProductSelectedValues(productId, axes)
					: await this.getSelectedAttributeValues(axes);

			// Generate all possible combinations
			const combinations = this.generateVariantCombinations(axes, selectedValues);

			this.logger.info(`Generated ${combinations.length} variant combinations for product ${productId}`);

			// Get existing variants
			const existingVariants = await this.knex('products')
				.where('parent_product_id', productId)
				.where('product_type', 'simple')
				.select('id', 'variant_attributes_hash');

			const existingHashes = new Map(existingVariants.map((v) => [v.variant_attributes_hash, v.id]));

			// Create missing variants
			const variantsToCreate = [];
			const validHashes = new Set<string>();

			for (const combination of combinations) {
				const hash = this.generateCombinationHash(combination);
				validHashes.add(hash);

				if (!existingHashes.has(hash)) {
					variantsToCreate.push({
						modelProduct,
						combination,
						hash,
					});
				}
			}

			// Batch create variants
			if (variantsToCreate.length > 0) {
				await this.createVariants(variantsToCreate);
				result.created = variantsToCreate.length;
			}

			// Delete obsolete variants
			const variantsToDelete = existingVariants
				.filter((v) => !validHashes.has(v.variant_attributes_hash))
				.map((v) => v.id);

			if (variantsToDelete.length > 0) {
				await this.deleteVariants(variantsToDelete);
				result.deleted = variantsToDelete.length;
			}

			// Log generation results
			await this.logGeneration(modelProduct.family_variant, productId, 'generate', result);

			return result;
		} catch (error) {
			this.logger.error(`Error generating variants for product ${productId}:`, error);
			result.errors.push(error instanceof Error ? error.message : String(error));
			return result;
		}
	}

	/**
	 * Get variant axes for a family variant
	 */
	private async getVariantAxes(familyVariantId: number): Promise<VariantAxis[]> {
		const axes = await this.knex('family_variant_axes as fva')
			.join('attributes as a', 'fva.attributes_id', 'a.id')
			.where('fva.family_variants_id', familyVariantId)
			.orderBy('fva.sort')
			.select(
				'fva.id',
				'fva.attributes_id as attribute_id',
				'a.code as attribute_code',
				'fva.selected_value_ids',
				'fva.sort',
			);

		return axes.map((axis) => ({
			...axis,
			selected_value_ids: axis.selected_value_ids
				? Array.isArray(axis.selected_value_ids)
					? axis.selected_value_ids
					: JSON.parse(axis.selected_value_ids)
				: [],
		}));
	}

	/**
	 * Get selected attribute values for the variant axes
	 * Supports both new relationship structure and legacy JSON approach
	 */
	private async getSelectedAttributeValues(axes: VariantAxis[]): Promise<Map<number, AttributeValue[]>> {
		const valueMap = new Map<number, AttributeValue[]>();

		for (const axis of axes) {
			try {
				// NEW APPROACH: Use family_variant_axis_values relationship
				const selectedAxisValues = await this.knex('family_variant_axis_values as fvav')
					.join('attribute_values as av', 'fvav.attribute_value_id', 'av.id')
					.where('fvav.family_variant_axis_id', axis.id)
					.where('fvav.is_selected', true)
					.orderBy('fvav.sort', 'asc')
					.select('av.id', 'av.value', 'av.label', 'av.attribute_id');

				if (selectedAxisValues.length > 0) {
					// Use the new relationship structure
					valueMap.set(axis.attribute_id, selectedAxisValues);
					this.logger.info(
						`Using new relationship structure for axis ${axis.id}: found ${selectedAxisValues.length} selected values`,
					);
					continue;
				}

				// FALLBACK: Use legacy JSON approach or get all values
				if (axis.selected_value_ids && axis.selected_value_ids.length > 0) {
					// Legacy: Get values from JSON field
					const values = await this.knex('attribute_values')
						.whereIn('id', axis.selected_value_ids)
						.orderBy('sort')
						.select('id', 'value', 'label', 'attribute_id');

					valueMap.set(axis.attribute_id, values);
					this.logger.info(`Using legacy JSON structure for axis ${axis.id}: found ${values.length} selected values`);
				} else {
					// Default: Get all values for the attribute
					const values = await this.knex('attribute_values')
						.where('attribute_id', axis.attribute_id)
						.orderBy('sort')
						.select('id', 'value', 'label', 'attribute_id');

					valueMap.set(axis.attribute_id, values);
					this.logger.info(`Using all values for axis ${axis.id}: found ${values.length} total values`);
				}
			} catch (error) {
				this.logger.error(`Error getting selected values for axis ${axis.id}:`, error);

				// Fallback to all values if there's an error
				const values = await this.knex('attribute_values')
					.where('attribute_id', axis.attribute_id)
					.orderBy('sort')
					.select('id', 'value', 'label', 'attribute_id');

				valueMap.set(axis.attribute_id, values);
			}
		}

		return valueMap;
	}

	/**
	 * Get selected attribute values for a specific product (product_model type)
	 * Uses the product_variant_selections table for product-level control
	 */
	private async getProductSelectedValues(
		productId: number,
		axes: VariantAxis[],
	): Promise<Map<number, AttributeValue[]>> {
		const valueMap = new Map<number, AttributeValue[]>();

		for (const axis of axes) {
			try {
				// Get selected values from product_variant_selections table
				const selectedValues = await this.knex('product_variant_selections as pvs')
					.join('attribute_values as av', 'pvs.attribute_value_id', 'av.id')
					.where('pvs.product_id', productId)
					.where('pvs.attribute_id', axis.attribute_id)
					.where('pvs.is_selected', true)
					.orderBy('pvs.sort', 'asc')
					.select('av.id', 'av.value', 'av.label', 'av.attribute_id');

				if (selectedValues.length > 0) {
					valueMap.set(axis.attribute_id, selectedValues);
					this.logger.info(
						`Using product-level selections for product ${productId}, axis ${axis.id}: found ${selectedValues.length} selected values`,
					);
				} else {
					// Fallback to family variant selections if no product-level selections exist
					this.logger.info(
						`No product-level selections found for product ${productId}, axis ${axis.id}, falling back to family variant selections`,
					);
					const fallbackValues = await this.getSelectedAttributeValues([axis]);
					const axisValues = fallbackValues.get(axis.attribute_id);
					if (axisValues) {
						valueMap.set(axis.attribute_id, axisValues);
					}
				}
			} catch (error) {
				this.logger.error(`Error getting product-level selections for product ${productId}, axis ${axis.id}:`, error);
				// Fallback to family variant selections
				const fallbackValues = await this.getSelectedAttributeValues([axis]);
				const axisValues = fallbackValues.get(axis.attribute_id);
				if (axisValues) {
					valueMap.set(axis.attribute_id, axisValues);
				}
			}
		}

		return valueMap;
	}

	/**
	 * Generate all possible variant combinations from axes and their values
	 */
	private generateVariantCombinations(
		axes: VariantAxis[],
		selectedValues: Map<number, AttributeValue[]>,
	): VariantCombination[] {
		if (axes.length === 0) return [];

		const combinations: VariantCombination[] = [];

		// Recursive function to generate combinations
		const generateCombination = (axisIndex: number, currentCombination: VariantCombination): void => {
			if (axisIndex === axes.length) {
				combinations.push({ ...currentCombination });
				return;
			}

			const axis = axes[axisIndex];
			const values = selectedValues.get(axis.attribute_id) || [];

			for (const value of values) {
				currentCombination[axis.attribute_code] = {
					id: value.id,
					value: value.value,
					label: value.label,
					attribute_id: value.attribute_id,
				};
				generateCombination(axisIndex + 1, currentCombination);
			}
		};

		generateCombination(0, {});
		return combinations;
	}

	/**
	 * Generate a hash for a variant combination for deduplication
	 */
	private generateCombinationHash(combination: VariantCombination): string {
		const sorted = Object.keys(combination)
			.sort()
			.map((key) => `${key}:${combination[key].id}`)
			.join('|');

		return createHash('sha256').update(sorted).digest('hex');
	}

	/**
	 * Create variant products in batch
	 */
	private async createVariants(
		variants: Array<{
			modelProduct: Record<string, any>;
			combination: VariantCombination;
			hash: string;
		}>,
	): Promise<void> {
		// Use transaction for consistency
		await this.knex.transaction(async (trx) => {
			// Create products in batch
			const productData = variants.map((variant) => ({
				parent_product_id: variant.modelProduct.id,
				product_type: 'simple',
				family: variant.modelProduct.family,
				family_variant: variant.modelProduct.family_variant,
				variant_attributes_hash: variant.hash,
				enabled: false, // Start disabled, can be enabled later
			}));

			const createdProducts = await trx('products').insert(productData).returning(['id', 'variant_attributes_hash']);

			// Create a map of hash to product ID
			const hashToId = new Map(createdProducts.map((p) => [p.variant_attributes_hash, p.id]));

			// Prepare attribute assignments
			const attributeAssignments = [];

			for (const variant of variants) {
				const productId = hashToId.get(variant.hash);
				if (!productId) continue;

				for (const [, attributeData] of Object.entries(variant.combination)) {
					attributeAssignments.push({
						products_id: productId,
						attributes_id: attributeData.attribute_id,
						value: JSON.stringify(attributeData.value),
					});
				}
			}

			// Insert attribute assignments in batch
			if (attributeAssignments.length > 0) {
				await trx('product_attributes').insert(attributeAssignments);
			}
		});
	}

	/**
	 * Delete obsolete variants
	 */
	private async deleteVariants(variantIds: number[]): Promise<void> {
		const { ItemsService } = this.services;
		const itemsService = new ItemsService('products', {
			accountability: this.accountability,
			schema: this.schema,
		});
		await itemsService.deleteMany(variantIds);
	}

	/**
	 * Update selected values for a variant axis
	 */
	async updateAxisValueSelections(familyVariantAxisId: number, selectedValueIds: number[]): Promise<void> {
		await this.knex('family_variant_axes')
			.where('id', familyVariantAxisId)
			.update({
				selected_value_ids: JSON.stringify(selectedValueIds),
			});

		// Get the family variant ID
		const axis = await this.knex('family_variant_axes').where('id', familyVariantAxisId).first();

		if (axis) {
			// Regenerate variants for this family variant
			await this.generateVariantsForFamilyVariant(axis.family_variants_id);
		}
	}

	/**
	 * Get available values for an attribute
	 */
	async getAvailableValuesForAxis(attributeId: number): Promise<AttributeValue[]> {
		return await this.knex('attribute_values')
			.where('attribute_id', attributeId)
			.orderBy('sort')
			.select('id', 'value', 'label', 'attribute_id');
	}

	/**
	 * Remove obsolete variants after configuration change
	 */
	async removeObsoleteVariants(familyVariantId: number, validCombinations: VariantCombination[]): Promise<number> {
		const validHashes = new Set(validCombinations.map((combo) => this.generateCombinationHash(combo)));

		// Find all products using this family variant
		const modelProducts = await this.knex('products')
			.where('family_variant', familyVariantId)
			.where('product_type', 'model')
			.select('id');

		let totalDeleted = 0;

		for (const modelProduct of modelProducts) {
			// Get all variants for this model
			const variants = await this.knex('products')
				.where('parent_product_id', modelProduct.id)
				.where('product_type', 'simple')
				.select('id', 'variant_attributes_hash');

			// Find obsolete variants
			const obsoleteIds = variants.filter((v) => !validHashes.has(v.variant_attributes_hash)).map((v) => v.id);

			if (obsoleteIds.length > 0) {
				await this.deleteVariants(obsoleteIds);
				totalDeleted += obsoleteIds.length;
			}
		}

		return totalDeleted;
	}

	/**
	 * Get the number of variant combinations that would be generated
	 * for a family variant (for UX preview)
	 */
	async getVariantCombinationCount(familyVariantId: number): Promise<number> {
		try {
			// Get variant axes
			const axes = await this.getVariantAxes(familyVariantId);

			if (axes.length === 0) {
				return 0;
			}

			// Get selected values for each axis
			const selectedValues = await this.getSelectedAttributeValues(axes);

			// Calculate total combinations
			let totalCombinations = 1;

			for (const axis of axes) {
				const values = selectedValues.get(axis.attribute_id) || [];
				totalCombinations *= values.length;
			}

			return totalCombinations;
		} catch (error) {
			this.logger.error(`Error calculating variant combination count for family variant ${familyVariantId}:`, error);
			return 0;
		}
	}

	/**
	 * Get detailed combination breakdown for UX preview
	 */
	async getVariantCombinationBreakdown(familyVariantId: number): Promise<{
		axes: Array<{
			attribute_code: string;
			attribute_label: string;
			selected_count: number;
			total_count: number;
		}>;
		total_combinations: number;
	}> {
		try {
			const axes = await this.getVariantAxes(familyVariantId);
			const selectedValues = await this.getSelectedAttributeValues(axes);

			const breakdown = {
				axes: [] as Array<{
					attribute_code: string;
					attribute_label: string;
					selected_count: number;
					total_count: number;
				}>,
				total_combinations: 1,
			};

			for (const axis of axes) {
				const values = selectedValues.get(axis.attribute_id) || [];

				// Get total count for this attribute
				const totalValues = await this.knex('attribute_values')
					.where('attribute_id', axis.attribute_id)
					.count('id as count')
					.first();

				const axisInfo = {
					attribute_code: axis.attribute_code,
					attribute_label: axis.attribute_code, // You may want to join to get actual label
					selected_count: values.length,
					total_count: Number(totalValues?.count || 0),
				};

				breakdown.axes.push(axisInfo);
				breakdown.total_combinations *= values.length;
			}

			return breakdown;
		} catch (error) {
			this.logger.error(`Error getting variant combination breakdown for family variant ${familyVariantId}:`, error);
			return { axes: [], total_combinations: 0 };
		}
	}

	/**
	 * Log variant generation activity
	 */
	private async logGeneration(
		familyVariantId: number,
		modelProductId: number | null,
		action: string,
		result: GenerationResult,
	): Promise<void> {
		try {
			await this.knex('variant_generation_logs').insert({
				family_variant_id: familyVariantId,
				model_product_id: modelProductId,
				action,
				variants_created: result.created,
				variants_updated: result.updated,
				variants_deleted: result.deleted,
				details: JSON.stringify({
					errors: result.errors,
					timestamp: new Date().toISOString(),
				}),
			});
		} catch (error) {
			this.logger.error('Failed to log variant generation:', error);
		}
	}
}
